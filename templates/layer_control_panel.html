<!-- Layer Control Panel UI Template for APPEIT Map Creator -->
<!-- This template provides the collapsible right panel with grouped layer controls and search -->

<style>
    /* Right side panel container */
    #layer-control-panel {
        position: fixed;
        top: 0;
        right: 0;
        width: 350px;
        height: 100vh;
        background: white;
        box-shadow: -2px 0 8px rgba(0,0,0,0.2);
        z-index: 1001;
        transition: transform 0.3s ease-in-out;
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
    }

    #layer-control-panel.collapsed {
        transform: translateX(350px);
    }

    /* Adjust Leaflet controls position to account for right panel */
    body:not(.panel-right-collapsed) .leaflet-right {
        right: 350px !important;
        transition: right 0.3s ease-in-out;
    }

    body.panel-right-collapsed .leaflet-right {
        right: 0 !important;
        transition: right 0.3s ease-in-out;
    }

    /* Adjust download control position to account for right panel */
    body:not(.panel-right-collapsed) .leaflet-control-download {
        right: 360px !important;
        transition: right 0.3s ease-in-out;
    }

    body.panel-right-collapsed .leaflet-control-download {
        right: 10px !important;
        transition: right 0.3s ease-in-out;
    }

    /* Toggle button - positioned on left edge of panel */
    #layer-panel-toggle {
        position: absolute;
        top: 50%;
        left: -20px;
        transform: translateY(-50%);
        width: 20px;
        height: 60px;
        background: white;
        border: 2px solid rgba(0,0,0,0.2);
        border-right: none;
        border-radius: 8px 0 0 8px;
        box-shadow: -2px 0 6px rgba(0,0,0,0.15);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        color: #333;
        transition: background 0.2s;
    }

    #layer-panel-toggle:hover {
        background: #e0e0e0;
    }

    /* Panel content area */
    .layer-panel-content {
        padding: 20px;
        overflow-y: auto;
        flex: 1;
    }

    /* Search section */
    .search-section {
        margin-bottom: 15px;
    }

    .search-container {
        position: relative;
    }

    .search-icon {
        position: absolute;
        left: 10px;
        top: 50%;
        transform: translateY(-50%);
        color: #6e6e6e;
        font-size: 14px;
        pointer-events: none;
    }

    .search-section input {
        width: 100%;
        padding: 8px 12px 8px 32px;  /* Extra left padding for icon */
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 13px;
        font-family: Arial, sans-serif;
        box-sizing: border-box;
    }

    .search-section input:focus {
        outline: none;
        border-color: #0078A8;
        box-shadow: 0 0 0 2px rgba(0, 120, 168, 0.1);
    }

    /* Input geometry section */
    .input-geometry-section {
        margin-bottom: 12px;
        padding-bottom: 12px;
        border-bottom: 1px solid #ddd;
    }

    .input-geometry-section .layer-label {
        font-weight: 600;
        color: #555;
    }

    /* Layer groups section */
    .layer-groups {
        margin-top: 10px;
    }

    .layer-group {
        margin-bottom: 15px;
    }

    .group-header {
        display: flex;
        align-items: center;
        padding: 8px 0;
        border-bottom: 2px solid #ddd;
        margin-bottom: 8px;
        cursor: pointer;
        user-select: none;
    }

    .group-header:hover {
        background: #f8f9fa;
    }

    .group-header input[type="checkbox"] {
        margin-right: 8px;
        cursor: pointer;
        width: 16px;
        height: 16px;
    }

    .group-header label {
        flex: 1;
        font-weight: bold;
        font-size: 13px;
        color: #333;
        cursor: pointer;
        margin: 0;
    }

    .group-chevron {
        font-size: 12px;
        color: #666;
        transition: transform 0.2s;
        margin-left: 5px;
    }

    .layer-group.collapsed .group-chevron {
        transform: rotate(-90deg);
    }

    .group-layers {
        padding-left: 10px;
        transition: max-height 0.3s ease-in-out;
        overflow: hidden;
    }

    .layer-group.collapsed .group-layers {
        max-height: 0 !important;
    }

    .layer-item {
        display: flex;
        align-items: center;
        padding: 6px 8px;
        margin: 4px 0;
        border-radius: 4px;
        transition: background 0.2s;
    }

    .layer-item:hover {
        background: #f0f0f0;
    }

    .drag-handle {
        font-size: 12px;
        color: #999;
        margin-right: 8px;
        cursor: grab;
    }

    .layer-item input[type="checkbox"] {
        margin-right: 8px;
        cursor: pointer;
        width: 14px;
        height: 14px;
    }

    .layer-item i {
        font-size: 14px;
        margin-right: 8px;
    }

    .layer-item label {
        flex: 1;
        font-size: 12px;
        color: #333;
        cursor: pointer;
        margin: 0;
    }

    .layer-count {
        font-size: 11px;
        color: #666;
        margin-left: 5px;
    }

    /* Line symbol for line layers */
    .line-symbol {
        width: 20px;
        height: 2px;
        margin-right: 8px;
        display: inline-block;
    }

    /* Polygon symbol for polygon layers */
    .polygon-symbol {
        width: 16px;
        height: 16px;
        margin-right: 8px;
        display: inline-block;
        border: 2px solid;
    }

    /* Parent/child layer items for unique value symbology */
    .layer-item-parent {
        font-weight: 500;
    }

    .layer-item-child {
        padding: 6px 8px 6px 32px;
        font-size: 12px;
        display: flex;
        align-items: center;
        border-bottom: 1px solid #eee;
        background: #fafafa;
    }

    .layer-item-child:last-child {
        border-bottom: 1px solid #ddd;
    }

    .layer-item-child svg {
        flex-shrink: 0;
    }

    /* No results message */
    .no-results {
        text-align: center;
        padding: 20px;
        color: #999;
        font-size: 13px;
        display: none;
    }

    /* Custom scrollbar */
    .layer-panel-content::-webkit-scrollbar {
        width: 8px;
    }

    .layer-panel-content::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 4px;
    }

    .layer-panel-content::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 4px;
    }

    .layer-panel-content::-webkit-scrollbar-thumb:hover {
        background: #555;
    }
</style>

<div id="layer-control-panel">
    <div id="layer-panel-toggle" onclick="toggleLayerPanel()">
        <span id="layer-toggle-icon">►</span>
    </div>

    <div class="layer-panel-content">
        <!-- Search Box -->
        <div class="search-section">
            <div class="search-container">
                <i class="fa fa-search search-icon"></i>
                <input type="text"
                       id="layer-search"
                       placeholder="Search layers..."
                       oninput="filterLayers(this.value)">
            </div>
        </div>

        <!-- Input Geometry Toggle Section -->
        <div class="input-geometry-section">
            <div class="layer-item">
                <input type="checkbox"
                       id="input-geometry-toggle"
                       class="layer-checkbox"
                       checked
                       onchange="toggleInputGeometry(this.checked)">
                <label for="input-geometry-toggle" class="layer-label">
                    <svg width="20" height="15" style="margin-right: 8px; vertical-align: middle;">
                        <rect width="20" height="15"
                              style="fill:#FFD700; stroke:#FF8C00; stroke-width:2; opacity:0.4;" />
                    </svg>
                    <span>{{ input_filename }}</span>
                </label>
            </div>
        </div>

        <!-- Layer Groups -->
        <div class="layer-groups" id="layer-groups-container">
            {% for group in groups %}
            <div class="layer-group" data-group="{{ group.name }}">
                <div class="group-header" onclick="toggleGroupExpand('{{ group.name }}')">
                    <input type="checkbox"
                           id="group-{{ group.name|replace(' ', '-')|replace('/', '-')|lower }}"
                           checked
                           onclick="event.stopPropagation(); toggleGroup('{{ group.name }}', this.checked)">
                    <label onclick="event.stopPropagation(); document.getElementById('group-{{ group.name|replace(' ', '-')|replace('/', '-')|lower }}').click();">
                        {{ group.name }}
                    </label>
                    <span class="group-chevron">▼</span>
                </div>

                <div class="group-layers">
                    {% for layer in group.layers %}
                    {% if layer.category_symbols %}
                    <!-- Layer with unique value symbology - show parent + categories -->
                    <div class="layer-item layer-item-parent"
                         data-layer-name="{{ layer.name }}"
                         data-description="{{ layer.description }}"
                         data-group="{{ layer.group }}">
                        <span class="drag-handle">⋮⋮</span>
                        <input type="checkbox"
                               id="layer-{{ layer.name|replace(' ', '-')|lower }}"
                               checked
                               onchange="toggleLayer('{{ layer.name }}', this.checked)">

                        <label onclick="document.getElementById('layer-{{ layer.name|replace(' ', '-')|lower }}').click();">
                            {{ layer.name }} <span class="layer-count">({{ layer.feature_count }} total)</span>
                        </label>
                    </div>
                    <!-- Category entries (vertical layout) -->
                    {% for symbol in layer.category_symbols %}
                    <div class="layer-item-child" data-layer-name="{{ layer.name }}">
                        {% if symbol.geometry_type == 'line' %}
                        <!-- Line symbology: colored line -->
                        <svg width="20" height="14" style="margin-right: 6px; vertical-align: middle;">
                            <line x1="0" y1="7" x2="20" y2="7"
                                  style="stroke:{{ symbol.color }}; stroke-width:{{ symbol.weight|default(3) }}; opacity:{{ symbol.opacity|default(0.8) }};" />
                        </svg>
                        {% elif symbol.geometry_type == 'point' %}
                        <!-- Point symbology: Font Awesome icon with color -->
                        <i class="fa fa-{{ symbol.icon }}"
                           style="color: {{ symbol.icon_color }}; margin-right: 8px; font-size: 14px; vertical-align: middle;"></i>
                        {% elif symbol.geometry_type == 'polygon' %}
                            {% if symbol.fill_pattern %}
                            <!-- Polygon with pattern fill -->
                            <svg width="14" height="14" style="margin-right: 6px; vertical-align: middle;">
                                <defs>
                                    <pattern id="lcp-pattern-{{ layer.name|replace(' ', '-')|lower }}-{{ symbol.label|replace(' ', '-')|lower }}"
                                             patternUnits="userSpaceOnUse"
                                             width="{{ (symbol.fill_pattern.weight|default(3) + symbol.fill_pattern.space_weight|default(3)) }}"
                                             height="{{ (symbol.fill_pattern.weight|default(3) + symbol.fill_pattern.space_weight|default(3)) }}"
                                             patternTransform="rotate({{ symbol.fill_pattern.angle|default(-45) }} 0 0)">
                                        <line x1="0" y1="0" x2="0" y2="{{ (symbol.fill_pattern.weight|default(3) + symbol.fill_pattern.space_weight|default(3)) }}"
                                              style="stroke:{{ symbol.fill_color }}; stroke-width:{{ symbol.fill_pattern.weight|default(3) }}; opacity:{{ symbol.fill_pattern.opacity|default(0.75) }};" />
                                    </pattern>
                                </defs>
                                <rect width="14" height="14"
                                      style="fill:url(#lcp-pattern-{{ layer.name|replace(' ', '-')|lower }}-{{ symbol.label|replace(' ', '-')|lower }}); stroke:{{ symbol.border_color }}; stroke-width:1;" />
                            </svg>
                            {% else %}
                            <!-- Polygon with solid fill -->
                            <svg width="14" height="14" style="margin-right: 6px; vertical-align: middle;">
                                <rect width="14" height="14"
                                      style="fill:{{ symbol.fill_color }}; fill-opacity:{{ symbol.fill_opacity }}; stroke:{{ symbol.border_color }}; stroke-width:1;" />
                            </svg>
                            {% endif %}
                        {% endif %}
                        <span>{{ symbol.label }} <span class="layer-count">({{ symbol.count }})</span></span>
                    </div>
                    {% endfor %}
                    {% else %}
                    <!-- Standard layer item (no unique value symbology) -->
                    <div class="layer-item"
                         data-layer-name="{{ layer.name }}"
                         data-description="{{ layer.description }}"
                         data-group="{{ layer.group }}">
                        <span class="drag-handle">⋮⋮</span>
                        <input type="checkbox"
                               id="layer-{{ layer.name|replace(' ', '-')|lower }}"
                               checked
                               onchange="toggleLayer('{{ layer.name }}', this.checked)">

                        {% if layer.geometry_type == 'point' %}
                        <i class="fa fa-{{ layer.icon }}" style="color: {{ layer.icon_color }}"></i>
                        {% elif layer.geometry_type == 'line' %}
                        <span class="line-symbol" style="background-color: {{ layer.color }}"></span>
                        {% elif layer.geometry_type == 'polygon' %}
                            {% if layer.fill_pattern and layer.fill_pattern.type == 'stripe' %}
                            <!-- SVG hatched pattern symbol -->
                            {% set pattern_id = 'control-hatch-' ~ layer.name|replace(' ', '-')|lower %}
                            <svg width="16" height="16" style="margin-right: 8px; vertical-align: middle; flex-shrink: 0;">
                                <defs>
                                    <pattern id="{{ pattern_id }}" width="4" height="4" patternUnits="userSpaceOnUse" patternTransform="rotate({{ layer.fill_pattern.angle|default(-45) }})">
                                        <line x1="0" y1="0" x2="0" y2="4" stroke="{{ layer.color }}" stroke-width="1.5" opacity="{{ layer.fill_pattern.opacity|default(0.75) }}"/>
                                    </pattern>
                                </defs>
                                <rect width="16" height="16" style="fill:url(#{{ pattern_id }}); stroke:{{ layer.color }}; stroke-width:1;" />
                            </svg>
                            {% else %}
                            <!-- Solid fill polygon symbol -->
                            <svg width="14" height="14" style="margin-right: 8px; vertical-align: middle; flex-shrink: 0;">
                                <rect width="14" height="14" style="fill:{{ layer.fill_color }}; fill-opacity:{{ layer.fill_opacity }}; stroke:{{ layer.color }}; stroke-width:1;" />
                            </svg>
                            {% endif %}
                        {% endif %}

                        <label onclick="document.getElementById('layer-{{ layer.name|replace(' ', '-')|lower }}').click();">
                            {{ layer.name }} <span class="layer-count">({{ layer.feature_count }})</span>
                        </label>
                    </div>
                    {% endif %}
                    {% endfor %}
                </div>
            </div>
            {% endfor %}
        </div>

        <!-- No results message -->
        <div class="no-results" id="no-results">
            No layers found matching your search.
        </div>
    </div>
</div>

<script>
    // Store layer objects for show/hide functionality
    const mapLayers = {};
    const layerStates = {};
    const groupLayerStates = {};

    // Ordered list of layer names from UI (top to bottom = front to back visually)
    // This gets populated on initialization from the DOM
    var layerOrderList = [];

    // Restore layer z-order based on list position
    // Layers at TOP of list should render on TOP visually
    function restoreLayerOrder() {
        if (!window.mapObject) return;

        // Iterate in REVERSE order (bottom of list first)
        // so that layers at TOP of list end up on TOP visually
        for (var i = layerOrderList.length - 1; i >= 0; i--) {
            var layerName = layerOrderList[i];
            var layer = mapLayers[layerName];

            if (layer && layerStates[layerName] && layer.bringToFront) {
                layer.bringToFront();
            }
        }

        // Input polygon is first in list (above environmental layers),
        // so bring it to front last to ensure it renders on top
        var inputToggle = document.getElementById('input-geometry-toggle');
        if (window.inputPolygonLayer && inputToggle && inputToggle.checked) {
            if (window.inputPolygonLayer.bringToFront) {
                window.inputPolygonLayer.bringToFront();
            }
        }
    }

    // Toggle layer control panel collapse/expand
    function toggleLayerPanel() {
        var panel = document.getElementById('layer-control-panel');
        var icon = document.getElementById('layer-toggle-icon');

        panel.classList.toggle('collapsed');
        document.body.classList.toggle('panel-right-collapsed');
        // Fixed: arrow points in direction panel will move when clicked
        icon.textContent = panel.classList.contains('collapsed') ? '◄' : '►';
    }

    // Toggle input geometry visibility
    function toggleInputGeometry(visible) {
        if (window.inputPolygonLayer && window.mapObject) {
            if (visible) {
                window.mapObject.addLayer(window.inputPolygonLayer);
                restoreLayerOrder();  // Restore proper z-order
            } else {
                window.mapObject.removeLayer(window.inputPolygonLayer);
            }
        }
    }

    // Toggle group expand/collapse (visual only)
    function toggleGroupExpand(groupName) {
        var groupElement = document.querySelector('.layer-group[data-group="' + groupName + '"]');
        if (groupElement) {
            groupElement.classList.toggle('collapsed');
        }
    }

    // Toggle all layers in a group
    function toggleGroup(groupName, isChecked) {
        // Get all layer checkboxes in this group
        var groupElement = document.querySelector('.layer-group[data-group="' + groupName + '"]');
        if (!groupElement) return;

        var layerCheckboxes = groupElement.querySelectorAll('.layer-item input[type="checkbox"]');

        // If turning on group, restore previous individual states
        if (isChecked) {
            if (groupLayerStates[groupName]) {
                // Restore previous states
                layerCheckboxes.forEach(function(checkbox) {
                    var layerName = checkbox.id.replace('layer-', '').replace(/-/g, ' ');
                    var layerItem = checkbox.closest('.layer-item');
                    var actualLayerName = layerItem ? layerItem.dataset.layerName : null;

                    if (actualLayerName && groupLayerStates[groupName][actualLayerName] !== undefined) {
                        checkbox.checked = groupLayerStates[groupName][actualLayerName];
                        toggleLayer(actualLayerName, checkbox.checked);
                    } else {
                        checkbox.checked = true;
                        if (actualLayerName) {
                            toggleLayer(actualLayerName, true);
                        }
                    }
                });
            } else {
                // Turn all on
                layerCheckboxes.forEach(function(checkbox) {
                    var layerItem = checkbox.closest('.layer-item');
                    var layerName = layerItem ? layerItem.dataset.layerName : null;
                    if (layerName) {
                        checkbox.checked = true;
                        toggleLayer(layerName, true);
                    }
                });
            }
        } else {
            // Save current states before turning off
            if (!groupLayerStates[groupName]) {
                groupLayerStates[groupName] = {};
            }

            layerCheckboxes.forEach(function(checkbox) {
                var layerItem = checkbox.closest('.layer-item');
                var layerName = layerItem ? layerItem.dataset.layerName : null;
                if (layerName) {
                    groupLayerStates[groupName][layerName] = checkbox.checked;
                    checkbox.checked = false;
                    toggleLayer(layerName, false);
                }
            });
        }

        // Dispatch custom event for legend sync
        document.dispatchEvent(new CustomEvent('layerVisibilityChanged'));
    }

    // Toggle individual layer visibility
    function toggleLayer(layerName, isVisible) {
        // Store layer state
        layerStates[layerName] = isVisible;

        // Get the layer object from the map
        var layer = mapLayers[layerName];

        if (layer && window.mapObject) {
            if (isVisible) {
                window.mapObject.addLayer(layer);
                restoreLayerOrder();  // Restore proper z-order
            } else {
                window.mapObject.removeLayer(layer);
            }
        }

        // Update group checkbox state
        updateGroupCheckboxState(layerName);

        // Dispatch custom event for legend sync
        document.dispatchEvent(new CustomEvent('layerVisibilityChanged', {
            detail: { layerName: layerName, isVisible: isVisible }
        }));
    }

    // Update group checkbox based on child layer states
    function updateGroupCheckboxState(layerName) {
        // Find which group this layer belongs to
        var layerItem = document.querySelector('.layer-item[data-layer-name="' + layerName + '"]');
        if (!layerItem) return;

        var groupName = layerItem.dataset.group;
        var groupCheckbox = document.getElementById('group-' + groupName.replace(/ /g, '-').replace(/\//g, '-').toLowerCase());
        if (!groupCheckbox) return;

        // Check if all layers in group are checked
        var groupElement = document.querySelector('.layer-group[data-group="' + groupName + '"]');
        var layerCheckboxes = groupElement.querySelectorAll('.layer-item input[type="checkbox"]');
        var allChecked = Array.from(layerCheckboxes).every(cb => cb.checked);
        var noneChecked = Array.from(layerCheckboxes).every(cb => !cb.checked);

        if (allChecked) {
            groupCheckbox.checked = true;
            groupCheckbox.indeterminate = false;
        } else if (noneChecked) {
            groupCheckbox.checked = false;
            groupCheckbox.indeterminate = false;
        } else {
            groupCheckbox.checked = false;
            groupCheckbox.indeterminate = true;
        }
    }

    // Filter layers by search term
    function filterLayers(searchTerm) {
        var term = searchTerm.toLowerCase().trim();
        var layerItems = document.querySelectorAll('.layer-item');
        var childItems = document.querySelectorAll('.layer-item-child');
        var groups = document.querySelectorAll('.layer-group');
        var hasVisibleLayers = false;

        if (term === '') {
            // Show all layers and their children
            layerItems.forEach(function(item) {
                item.style.display = 'flex';
            });
            childItems.forEach(function(child) {
                child.style.display = 'flex';
            });
            groups.forEach(function(group) {
                group.style.display = 'block';
            });
            document.getElementById('no-results').style.display = 'none';
            return;
        }

        // Filter layers and hide all children initially
        childItems.forEach(function(child) {
            child.style.display = 'none';
        });

        layerItems.forEach(function(item) {
            // Add null/undefined checks to prevent errors on elements without data attributes
            var name = (item.dataset.layerName || '').toLowerCase();
            var description = (item.dataset.description || '').toLowerCase();
            var group = (item.dataset.group || '').toLowerCase();

            var matches = name.includes(term) || description.includes(term) || group.includes(term);

            if (matches) {
                item.style.display = 'flex';
                hasVisibleLayers = true;
                // Show child items for matching layers
                var layerName = item.dataset.layerName;
                if (layerName) {
                    childItems.forEach(function(child) {
                        if (child.dataset.layerName === layerName) {
                            child.style.display = 'flex';
                        }
                    });
                }
            } else {
                item.style.display = 'none';
            }
        });

        // Hide groups with no visible layers
        groups.forEach(function(group) {
            var visibleLayers = group.querySelectorAll('.layer-item[style*="flex"]');
            if (visibleLayers.length > 0) {
                group.style.display = 'block';
            } else {
                group.style.display = 'none';
            }
        });

        // Show/hide no results message
        document.getElementById('no-results').style.display = hasVisibleLayers ? 'none' : 'block';
    }

    // Initialize layer states
    document.addEventListener('DOMContentLoaded', function() {
        // Build layer order list from DOM (in display order: top to bottom)
        // This defines the visual hierarchy: top of list = top of map
        var layerItems = document.querySelectorAll('.layer-item[data-layer-name]');
        layerItems.forEach(function(item) {
            var layerName = item.dataset.layerName;
            if (layerName && !layerOrderList.includes(layerName)) {
                layerOrderList.push(layerName);
            }
        });

        // All layers start as visible
        var layerCheckboxes = document.querySelectorAll('.layer-item input[type="checkbox"]');
        layerCheckboxes.forEach(function(checkbox) {
            var layerItem = checkbox.closest('.layer-item');
            var layerName = layerItem ? layerItem.dataset.layerName : null;
            if (layerName) {
                layerStates[layerName] = true;
            }
        });

        // Set initial max-height for group layers to enable collapse animation
        var groupLayers = document.querySelectorAll('.group-layers');
        groupLayers.forEach(function(group) {
            group.style.maxHeight = group.scrollHeight + 'px';
        });

        // Apply initial layer order after a delay to ensure map and layers are ready
        setTimeout(function() {
            restoreLayerOrder();
        }, 600);
    });
</script>
