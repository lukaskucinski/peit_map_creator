<!-- Download Control UI Template for APPEIT Map Creator -->
<!-- This template provides the download button and menu interface -->
<!-- @ts-nocheck - This is a Jinja2 template file, not pure JavaScript -->

<!-- CDN Libraries for Download Functionality -->
<script src="https://unpkg.com/@mapbox/shp-write@0.4.3/shpwrite.js"></script>
<script src="https://unpkg.com/tokml@0.4.0/tokml.js"></script>
<script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>

<style>
    /* Download control container */
    .leaflet-control-download {
        position: fixed;
        bottom: 50px;
        right: 10px;
        z-index: 1000;
    }

    /* Main download button - matches Leaflet control style */
    .download-button {
        background: white;
        border: 2px solid rgba(0,0,0,0.2);
        border-radius: 4px;
        box-shadow: 0 1px 5px rgba(0,0,0,0.4);
        width: 36px;
        height: 36px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        color: #333;
        transition: background 0.2s;
    }

    .download-button:hover {
        background: #f4f4f4;
    }

    /* Expanded menu panel */
    .download-menu {
        position: absolute;
        bottom: 0;
        right: 0;
        background: white;
        border: 2px solid rgba(0,0,0,0.2);
        border-radius: 4px;
        box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        padding: 12px;
        min-width: 240px;
        display: none;
        max-height: 500px;
        overflow-y: auto;
    }

    .download-menu.active {
        display: block;
    }

    /* Adjust menu position when right panel is OPEN to create margin between button and menu */
    body:not(.panel-right-collapsed) .download-menu.active {
        right: 45px;  /* Margin between download button and menu */
    }

    /* Adjust menu position when right panel is CLOSED to prevent overlap with button and toggle */
    body.panel-right-collapsed .download-menu.active {
        right: 45px;  /* Clear download button (36px) + toggle button (20px) + gaps */
    }

    .download-menu-header {
        font-weight: bold;
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 2px solid #ddd;
        font-size: 14px;
        color: #333;
    }

    .download-section {
        margin-bottom: 14px;
    }

    .download-layer-name {
        font-weight: 600;
        font-size: 12px;
        color: #555;
        margin-bottom: 6px;
    }

    .download-format-buttons {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
    }

    .download-format-btn {
        background: #0078A8;
        color: white;
        border: none;
        padding: 5px 10px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 11px;
        font-weight: 500;
        transition: background 0.2s;
    }

    .download-format-btn:hover {
        background: #005a80;
    }

    .download-format-btn:active {
        background: #004060;
    }

    .download-all-section {
        background: #f0f8ff;
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 14px;
        border: 1px solid #d0e8ff;
    }

    .download-all-section .download-layer-name {
        color: #0078A8;
        font-size: 13px;
    }

    /* Coordinate Context Menu (Google Maps-style) */
    .coordinate-context-menu {
        position: absolute;
        background: white;
        border-radius: 2px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        padding: 0;
        min-width: 200px;
        z-index: 10000;
        display: none;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    }

    .coordinate-context-menu.active {
        display: block;
    }

    .context-menu-item {
        padding: 12px 16px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
        color: #202124;
        transition: background 0.1s;
    }

    .context-menu-item:hover {
        background: #f1f3f4;
    }

    .context-menu-item .coord-text {
        flex: 1;
        font-family: monospace;
        font-size: 13px;
    }

    .context-menu-item i {
        color: #5f6368;
        margin-left: 12px;
        font-size: 14px;
    }

    /* Copy Notification (Google Maps-style) */
    .copy-notification {
        position: fixed;
        bottom: 24px;
        left: 50%;
        transform: translateX(-50%) translateY(100px);
        background: #323232;
        color: white;
        padding: 14px 24px;
        border-radius: 4px;
        font-size: 14px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        z-index: 10001;
        opacity: 0;
        transition: all 0.3s ease-in-out;
    }

    .copy-notification.show {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
</style>

<div class="leaflet-control-download">
    <div class="download-button" onclick="toggleDownloadMenu()" title="Download Layers">
        <i class="fa fa-download"></i>
    </div>

    <div class="download-menu" id="download-menu" onclick="closeDownloadMenuOnWhitespace(event)">
        <div class="download-menu-header" onclick="closeDownloadMenu()">
            <i class="fa fa-download"></i> Download Layers
        </div>

        <!-- Download All Section -->
        <div class="download-all-section">
            <div class="download-layer-name">All Layers</div>
            <div class="download-format-buttons">
                <button class="download-format-btn" onclick="downloadAll('geojson'); event.stopPropagation();">GeoJSON</button>
                <button class="download-format-btn" onclick="downloadAll('shp'); event.stopPropagation();">Shapefile</button>
                <button class="download-format-btn" onclick="downloadAll('kmz'); event.stopPropagation();">KMZ</button>
            </div>
        </div>

        <!-- Individual Layer Sections (injected by template) -->
        {{ layer_sections|safe }}
    </div>
</div>

<!-- Coordinate Context Menu -->
<div id="coordinate-menu" class="coordinate-context-menu">
    <div class="context-menu-item" onclick="copyCoordinates()">
        <span class="coord-text" id="coord-display"></span>
        <i class="fa fa-copy"></i>
    </div>
</div>

<!-- Copy Notification -->
<div id="copy-notification" class="copy-notification">
    Coordinates copied to clipboard
</div>

<script>
    // @ts-nocheck
    // Layer data embedded in page (GeoJSON objects)
    // Note: layer_data is Jinja2 template syntax, replaced at render time
    const layerData = {
        {{ layer_data|safe }}
    };

    function toggleDownloadMenu() {
        const menu = document.getElementById('download-menu');
        menu.classList.toggle('active');
    }

    function closeDownloadMenu() {
        const menu = document.getElementById('download-menu');
        menu.classList.remove('active');
    }

    // Close menu when clicking on whitespace or header
    function closeDownloadMenuOnWhitespace(event) {
        // Only close if clicking directly on the menu container (whitespace), not on its children
        if (event.target === event.currentTarget) {
            closeDownloadMenu();
        }
    }

    // Close menu when clicking outside
    document.addEventListener('click', function(event) {
        const control = document.querySelector('.leaflet-control-download');
        const menu = document.getElementById('download-menu');
        if (!control.contains(event.target) && menu.classList.contains('active')) {
            menu.classList.remove('active');
        }
    });

    // Get GeoJSON from embedded data (no fetch needed - fixes CORS issue)
    async function loadGeoJSON(layerName) {
        return layerData[layerName];
    }

    // Download individual layer in specified format
    async function downloadLayer(layerName, format) {
        const geojson = await loadGeoJSON(layerName);
        const fileName = layerName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '').toLowerCase();

        switch(format) {
            case 'geojson':
                downloadGeoJSON(geojson, fileName);
                break;
            case 'shp':
                downloadShapefile(geojson, fileName);
                break;
            case 'kmz':
                downloadKMZ(geojson, fileName);
                break;
        }
    }

    // Download all layers as a single ZIP file
    async function downloadAll(format) {
        try {
            const zip = new JSZip();
            let successCount = 0;
            let failCount = 0;

            for (const layerName of Object.keys(layerData)) {
                try {
                    const geojson = await loadGeoJSON(layerName);
                    const fileName = layerName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '').toLowerCase();

                    switch(format) {
                        case 'geojson':
                            zip.file(fileName + '.geojson', JSON.stringify(geojson, null, 2));
                            successCount++;
                            break;
                        case 'shp':
                            // Add shapefile as nested zip
                            try {
                                // Use outputType option to get Blob directly from @mapbox/shp-write
                                const options = {
                                    outputType: 'blob',
                                    compression: 'DEFLATE'
                                };

                                const shpBlob = await shpwrite.zip(geojson, options);

                                // Defensive check: verify we got a Blob
                                if (!(shpBlob instanceof Blob)) {
                                    const typeName = shpBlob?.constructor?.name || typeof shpBlob;
                                    console.error('Expected Blob but got:', typeName, 'for layer:', layerName);
                                    throw new Error(`Unexpected return type from shpwrite.zip(): ${typeName}`);
                                }

                                zip.file(fileName + '_shapefile.zip', shpBlob);
                                successCount++;
                            } catch (error) {
                                console.error(`Failed to generate shapefile for ${layerName}:`, error);
                                failCount++;
                            }
                            break;
                        case 'kmz':
                            const kml = tokml(geojson);
                            const kmzBlob = await createKMZBlob(kml);
                            zip.file(fileName + '.kmz', kmzBlob);
                            successCount++;
                            break;
                    }
                } catch (error) {
                    console.error(`Failed to process layer ${layerName}:`, error);
                    failCount++;
                }
            }

            if (successCount === 0) {
                throw new Error('No layers could be processed successfully');
            }

            // Generate and download ZIP
            const content = await zip.generateAsync({type: 'blob'});
            saveAs(content, 'all_layers_' + format + '.zip');

            if (failCount > 0) {
                alert(`Download complete. ${failCount} layer(s) had errors and were skipped.`);
            }
        } catch (error) {
            console.error('Download all failed:', error);
            alert('Failed to generate download. Please try downloading layers individually.');
        }
    }

    // Format-specific download functions
    function downloadGeoJSON(geojson, fileName) {
        const blob = new Blob([JSON.stringify(geojson, null, 2)], {type: 'application/json'});
        saveAs(blob, fileName + '.geojson');
    }

    async function downloadShapefile(geojson, fileName) {
        try {
            // Use outputType option to get Blob directly from @mapbox/shp-write
            const options = {
                outputType: 'blob',
                compression: 'DEFLATE'
            };

            const blob = await shpwrite.zip(geojson, options);

            // Defensive check: verify we got a Blob
            if (!(blob instanceof Blob)) {
                const typeName = blob?.constructor?.name || typeof blob;
                console.error('Expected Blob but got:', typeName, blob);
                throw new Error(`Unexpected return type from shpwrite.zip(): ${typeName}`);
            }

            saveAs(blob, fileName + '_shapefile.zip');
        } catch (error) {
            console.error('Shapefile download failed:', error);
            alert('Failed to generate shapefile. Please try GeoJSON or KMZ format instead.');
        }
    }

    async function downloadKMZ(geojson, fileName) {
        const kml = tokml(geojson);
        const kmzBlob = await createKMZBlob(kml);
        saveAs(kmzBlob, fileName + '.kmz');
    }

    async function createKMZBlob(kml) {
        const zip = new JSZip();
        zip.file('doc.kml', kml);
        return await zip.generateAsync({type: 'blob'});
    }

    // ========== Coordinate Context Menu Functions ==========

    let currentCoordinates = null;
    let leafletMap = null;

    // Initialize context menu after map is loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Find Leaflet map object - Folium creates variables like map_xxxxx
        setTimeout(function() {
            console.log('Searching for Leaflet map object...');

            // Search for map variable in window (Folium pattern: map_xxxxx)
            for (let key in window) {
                if (key.startsWith('map_') &&
                    window[key] &&
                    typeof window[key] === 'object' &&
                    typeof window[key].on === 'function') {
                    leafletMap = window[key];
                    console.log('Found Leaflet map object:', key);

                    // Use Leaflet's native contextmenu event
                    leafletMap.on('contextmenu', function(e) {
                        handleMapRightClick(e);
                    });
                    console.log('Context menu attached via Leaflet API');
                    break;
                }
            }

            if (!leafletMap) {
                console.error('Could not find Leaflet map object in window');
                // Log all window properties starting with 'map'
                console.log('Window properties starting with "map":',
                    Object.keys(window).filter(k => k.toLowerCase().includes('map')));
            }
        }, 2000);  // Increased timeout to ensure map is fully loaded

        // Close context menu when clicking anywhere
        document.addEventListener('click', closeCoordinateMenu);
    });

    function handleMapRightClick(e) {
        console.log('Right-click detected via Leaflet!', e);

        // Leaflet provides coordinates directly in e.latlng
        const lat = e.latlng.lat.toFixed(6);
        const lng = e.latlng.lng.toFixed(6);

        // Store coordinates
        currentCoordinates = `${lat}, ${lng}`;
        console.log('Coordinates:', currentCoordinates);

        // Update menu display
        document.getElementById('coord-display').textContent = currentCoordinates;

        // Position menu using the original DOM event
        const coordMenu = document.getElementById('coordinate-menu');
        coordMenu.style.left = e.originalEvent.pageX + 'px';
        coordMenu.style.top = e.originalEvent.pageY + 'px';
        coordMenu.classList.add('active');
        console.log('Context menu shown at:', e.originalEvent.pageX, e.originalEvent.pageY);
    }

    function closeCoordinateMenu() {
        const coordMenu = document.getElementById('coordinate-menu');
        coordMenu.classList.remove('active');
    }

    async function copyCoordinates() {
        if (!currentCoordinates) return;

        try {
            await navigator.clipboard.writeText(currentCoordinates);
            showCopyNotification();
            closeCoordinateMenu();
        } catch (err) {
            console.error('Failed to copy coordinates:', err);
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = currentCoordinates;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                showCopyNotification();
                closeCoordinateMenu();
            } catch (err2) {
                console.error('Fallback copy failed:', err2);
            }
            document.body.removeChild(textArea);
        }
    }

    function showCopyNotification() {
        const notification = document.getElementById('copy-notification');
        notification.classList.add('show');

        // Hide after 2 seconds (Google Maps style)
        setTimeout(function() {
            notification.classList.remove('show');
        }, 2000);
    }
</script>
